#ifndef AF_MULTIVARIATE_HH
#define AF_MULTIVARIATE_HH

#include <vector>
#include <string>
#include "TMVA/Reader.h"
#include "TMVA/Types.h"
#include "TGraph.h"
#include <unistd.h>
#include "TChain.h"
#include "../../../MaxCam/DmtpcSkimEvent.hh"

/* These are tools for multivariate analysis with cleanSkim */ 

namespace MultiVariate
{
  

   /* MVTree is a TTree but it should be one that was run through buildMVTree */ 
   typedef TTree MVTree;
 
  /** Create an MVTree with name name from a vector of filenames of skim files
   * \param name the name of the chain to create
   * \param files vector of files
   * \param cam_id the serial number of the camera to use, or 0 to use the first one
   * \param tree_name the name of the analysis tree to use 
   */ 
   MVTree * buildMVTree (const char * name, TFile * f,  const std::vector<std::string> * files, int nburnin_thresh = 2, const char * cam_id = 0, const char * tree_name = "skim", double true_cluster_distance = -1);
  
   /* Run a multivariate training and evaluation job with one method and background type.
    * \param job_name the name of the job, this will be used to retrieve it 
    * \param outputfile the output rootfile that contains the TMVA generated evaluation plots
    * \param signal signal tree generated by buildMVTree
    * \param background background tree generated by buildMVTree
    * \param method method to use 
    * \param method_options method options 
    * \param optimize_for_linear_discriminant optimize for linear discriminants by taking logs of most variables 
    * */ 
   void runMVSimple (const char * job_name,
          TFile * f, 
          MVTree * signal, 
          MVTree * background,
          const char * sig_cut = "", 
          const char * bg_cut = "", 
          TMVA::Types::EMVA method = TMVA::Types::kFisher,
          const char * method_options = ""
          ); 
	
   /** 
    * Run a multivariate training and evaluation job  with multiple methods and background types. 
    *
    * \param job_name the name of the job, this will be used to retrieved it
    * \param outputfile the output rootfile that contains the TMVA generated evaluation plots
    * \param signal Signal tree generated by buildMVTree
    * \param background array of background trees generated by buildMVTree
    * \param nbackground number of background trees
    * \param background_weights the weight associated with each background
    * \param methods array of methods
    * \param method_names given method name, used to retrieve it 
    * \param method_options array of method option strings
    * \param nmethods number of methods to use 
    * \param optimize_for_linear_discriminant optimize for linear discriminants by taking logs of most variables 
    */
   void runMVMultiple(const char * job_name,  
          TFile * f, 
          MVTree * signal,
          MVTree ** background,
          int nbackground, 
          const char * sig_cut , 
          const char * bg_cut , 
          const double * background_weights,
          const TMVA::Types::EMVA * methods, 
          const char ** method_names ,
          const char ** method_options ,
          int nmethods  
          );

	

   /**  A MultiVariateResult is a wrapper around the 
    *   TMVA Reader for DMTPC classes */ 
   class MultiVariateResult : public TObject
   {
     public: 


      /* Instantiate a MultiVariateResult object. 
       * will be used (which uses the log of most values instead of the values themselves) */ 
      MultiVariateResult(); 
      ~MultiVariateResult(); 

      /* Set the result to read from a weights file  given a job name, method name and path to the weights directory. If 
       * you used runMVSimple, the method name is the part after TMVA::Types::k otherwise it is what you gave it . */
      bool setResult(const char * job_name, const char * method_name = "Fisher",
                     const char * path_to_weights_dir="weights/"); 

      /* Get the classifier for a given track. If method_name is null, the last method selected using setResult is used. */
      double getClassifier(const DmtpcSkimEvent * ev, int cam, int track,
                           const char * method_name = NULL) ;     

      /* Get the cuts classifier for a given track  at a given signal efficiency (for the TMVA::cuts method).*/
      bool getCutsClassifier(const DmtpcSkimEvent * ev, int cam, int track,
                             double signal_efficency, const char * method_name = "Cuts");

      /* Get the signal probability given a signal fraction for a given signal efficiency. If method_name is NULL. the
       * last method selected using setResult is used */ 
      double getSignalProbability(const DmtpcSkimEvent * ev, int cam,
                                  int track, double signal_fraction,
                                  const char * method_name = NULL) ; 
     private:
      void setrdvars(const DmtpcSkimEvent * ev, int cam, int track) ; 
      bool optimized; 
      TMVA::Reader * reader; 
      char * current; //!
      float E, range,skewness,cluster_rms,cluster_mean,maxpixel,maxpixel_over_E,cluster_rms_over_E, 
         tmoment3,tmoment4,npixel,npixel_red,neighbors, logE,logrange,logcluster_rms,logmaxpixel,lognpixel,lognpixel_red;

     ClassDef(MultiVariateResult,3) 
   };




   /* 
    * Produces an evaluation output file 
    * Only the specified camera is considered. Any tracks with nbunriin > maxnburnin are ignored (unless maxnburnin is -1). 
    *
    */
   void evaluate(MultiVariateResult * result, MVTree * signal_ch,
                                        MVTree * bckgr_ch, const char * output_file = "mveval.root", 
                                        const char * sig_cam = 0, const char *  bg_cam = 0, int maxnburnin = -1, double true_cluster_distance = -1); 


   
}


#endif

