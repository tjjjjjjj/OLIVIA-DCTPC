#ifndef AF_MULTIVARIATE_HH
#define AF_MULTIVARIATE_HH

#include <vector>
#include <string>
#include "TMVA/Reader.h"
#include "TMVA/Types.h"
#include "TGraph.h"
#include <unistd.h>
#include "TChain.h"
#include "../../../MaxCam/DmtpcSkimEvent.hh"

/* These are tools for multivariate analysis with cleanSkim */ 

namespace MultiVariate
{
  

   /* MVTree is a TTree but it should be one that was run through buildMVTree */ 
   typedef TTree MVTree;
 
  /** Create an MVTree with name name from a vector of filenames of skim files
   * \param name the name of the chain to create
   * \param files vector of files
   * \param cams bitset of cameras to use. Least significant bit is cam 0, next is 1, etc. Default is 0x00000001 which correspopnds to cam 0
   */ 
   MVTree * buildMVTree (const char * name, const std::vector<std::string> * files, int nburnin_thresh = 2, uint32_t cams = 0x00000001);
  
   /* Run a multivariate training and evaluation job with one method and background type.
    * \param job_name the name of the job, this will be used to retrieve it 
    * \param outputfile the output rootfile that contains the TMVA generated evaluation plots
    * \param signal signal tree generated by buildMVTree
    * \param background background tree generated by buildMVTree
    * \param method method to use 
    * \param method_options method options 
    * \param optimize_for_linear_discriminant optimize for linear discriminants by taking logs of most variables 
    * */ 
   void runMVSimple (const char * job_name,
          const char * outputfile,
          MVTree * signal, 
          MVTree * background,
          TMVA::Types::EMVA method = TMVA::Types::kFisher,
          const char * method_options = "",
          bool optimize_for_linear_discriminant = true
          ); 
	
   /** 
    * Run a multivariate training and evaluation job  with multiple methods and background types. 
    *
    * \param job_name the name of the job, this will be used to retrieved it
    * \param outputfile the output rootfile that contains the TMVA generated evaluation plots
    * \param signal Signal tree generated by buildMVTree
    * \param background array of background trees generated by buildMVTree
    * \param nbackground number of background trees
    * \param background_weights the weight associated with each background
    * \param methods array of methods
    * \param method_names given method name, used to retrieve it 
    * \param method_options array of method option strings
    * \param nmethods number of methods to use 
    * \param optimize_for_linear_discriminant optimize for linear discriminants by taking logs of most variables 
    */
   void runMVMultiple(const char * job_name,  
          const char * outputfile, 
          MVTree * signal,
          MVTree ** background,
          int nbackground, 
          const double * background_weights,
          const TMVA::Types::EMVA * methods, 
          const char ** method_names ,
          const char ** method_options ,
          int nmethods  ,
          bool optimize_for_linear_discriminant
          );

	

   /**  A MultiVariateResult is a wrapper around the 
    *   TMVA Reader for DMTPC classes */ 
   class MultiVariateResult : public TObject
   {
     public: 


      /* Instantiate a MultiVariateResult object. If lda_optimized is used, the linear classifier optimization 
       * will be used (which uses the log of most values instead of the values themselves) */ 
      MultiVariateResult(bool lda_optimized = true); 
      ~MultiVariateResult(); 

      /* Set the result to read from a weights file  given a job name, method name and path to the weights directory. If 
       * you used runMVSimple, the method name is the part after TMVA::Types::k otherwise it is what you gave it . */
      bool setResult(const char * job_name, const char * method_name = "Fisher",
                     const char * path_to_weights_dir="weights/"); 

      /* Get the classifier for a given track. If method_name is null, the last method selected using setResult is used. */
      double getClassifier(const DmtpcSkimEvent * ev, int cam, int track,
                           const char * method_name = NULL) ;     

      /* Get the cuts classifier for a given track  at a given signal efficiency (for the TMVA::cuts method).*/
      bool getCutsClassifier(const DmtpcSkimEvent * ev, int cam, int track,
                             double signal_efficency, const char * method_name = "Cuts");

      /* Get the signal probability given a signal fraction for a given signal efficiency. If method_name is NULL. the
       * last method selected using setResult is used */ 
      double getSignalProbability(const DmtpcSkimEvent * ev, int cam,
                                  int track, double signal_fraction,
                                  const char * method_name = NULL) ; 
     private:
      void setrdvars(const DmtpcSkimEvent * ev, int cam, int track) ; 
      bool optimized; 
      TMVA::Reader * reader; 
      char * current; //!
      float E, range,skewness,cluster_rms,cluster_mean,maxpixel,
         moment2,moment3,moment4,
         tmoment2,tmoment3,tmoment4;
      int neighbors,npixel; 

     ClassDef(MultiVariateResult,1) 
   };



   /** 
    * The MultiVariateEvaluation class stores the result of calling the evaluate
    * method
    */

   class MultiVariateEvaluation : public TObject
   {
     public: 

       ~MultiVariateEvaluation(); 
       MultiVariateEvaluation(){;}
       MultiVariateEvaluation(TGraph * purity, TGraph * efficiency, TGraph * background, double cutoff);

       /* The purity of a point is defined as the weighted proportion of signal/background above each
        * classifier point */ 
       TGraph * purity() { return _purity;} 
       /* The signal efficiency at each classifier point */
       TGraph * efficiency() { return _efficiency;} 

       /* 1 - background efficiency at each classifier point */
       TGraph * background() { return _background;} 

       /* The point where background goes to 0 */ 
       double cutoff() { return _cutoff;}
       
     private:
       TGraph * _purity;     
       TGraph * _efficiency;     
       TGraph * _background;     

       double _cutoff;

     ClassDef(MultiVariateEvaluation,1) 
   };


   /* Computes a MultiVariateEvaluation for the given MultiVariateResult, signal chain and background chain. Note that this is 
    * different from the inherent evaluation that TMVA already does. 
    * Only the specified camera is considered. Any tracks with nbunriin > maxnburnin are ignored (unless maxnburnin is -1). 
    *
    */
   const MultiVariateEvaluation evaluate(MultiVariateResult * result, MVTree * signal_ch,
                                        MVTree * bckgr_ch, int sig_cam = 0, int bg_cam = 0, int maxnburnin = -1); 


/* NOT IMPLEMENTED YET
 * const MultiVariateEvaluation evaluate(const MultiVariateResult * result, const TChain * signal_ch, 
                                         const TChain * bckgr_ch, const char* camid , int maxnburnin = -1); 
                                         */

   
}


#endif

