#ifndef DMTPC_EVENT_HH
#define DMTPC_EVENT_HH

#include "TClonesArray.h"
#include "TObject.h"
#include "ScopeWaveformData.hh"
#include "MaxCamChannel.hh"
#include "TDatime.h"
#include "TTimeStamp.h"
#include "TH2F.h"

class MaxCamConfig;
class ScopeWaveform;
class ScopeDataInfo;
class MaxCamChannel;
class McDarkTrack;
class McDarkDigi;

class TDatime;
class TTimeStamp;
class TH1F;
class TH2F;

/**
A class to hold the data from a single event.

This class now stores data as TH1C and TH2S but 
will autoconvert on the fly to a TH2F when you ask for one.

The TH2F's are cached in memory so it's fine to ask for it for the same
event over and over again. 

Also note that this class has a handcoded Streamer because of some difficulties
we were having with the autogenerated streamers with caching. This means that if
any future data members are added, the Streamer should be updated (as well as the 
copy constructors, the destructor and the clearEventMemory in DmtpcDataset). 

\author Jeremy Lopez, Cosmin Deaconu (documentation)
*/
class DmtpcEvent : public TObject {

public:
    //
    // Ctors
/**
Constructor  
*/
    DmtpcEvent();
    
/**
Copy constructor
If copy_data is false, the _ccdData, _scopeData and _overscan are NOT 
copied. (used for data conversion)
@param other reference to DmtpcEvent to copy
#param copy_data whether or not to copy that data arrays
*/
    DmtpcEvent(const DmtpcEvent &other, bool copy_data = true);

    
/**
Destructor
*/
    virtual ~DmtpcEvent();
    
/**
Gets the name of the event. Always returns "DmtpcEvent"
@return "DmtpcEvent"
*/
    virtual const char* GetName() const { return "DmtpcEvent"; }  
    
/**
Maximum number of MaxCamChannel parameters to save
*/
    static const int MAX_N_CONFIG_PARAMETERS;

/**
\return the array of MaxCamChannel objects holding run configuration information
*/
    TClonesArray*  experimentConfig() { return _experConfig; }

/**
\param name the name of the parameter to find (e.g. "pressure", "wire_v")
\return the MaxCamChannel for a specific parameter
*/
    MaxCamChannel* experimentConfig(TString name);

/**
Print all of the environmental parameters.
*/
    void printExperimentConfig();

/**
\return the timestamp for the event
*/
    TDatime* timeStamp() const { return _dtime; }

/**
\return the UTC timestamp for the event
*/
    TTimeStamp* UTCtimeStamp() const {return _tstime;}
    
/**
\return an array holding all of the images as TH2F's. If the images are stored as
 as TH2S's, the TH2F clones array is generated and returned. Future calls from the same event
 are cached so there is no penalty for calling this multiple times before switching event. 
*/
    TClonesArray* ccdData();

/**
\param i the array index of the image to retrieve
\return a particular image. If images are stored as TH2S's, the relevant TH2F is generated
on the fly and returned. It will be cached for the life of the event. 
*/
    TH2F* ccdData(int i);

/**
\return an array holding all of the overscan data. If the overscans are
stored as TH2S's, the TH2F clones array is generated and returned. Future calls
from the same event are cached. 
*/
    TClonesArray* overscan();

/**
\param i the array index of the overscan to retrieve. 
\return a particular overscan. If the overscans 
are stored as TH2S's, the TH2F is generated on 
the fly and cached for the life of the event.
*/
    TH2F* overscan(int i);
    
/**
\return an array of configuration information for each camera
*/
    TClonesArray* ccdConfig() { return _ccdConfig; }

/**
\param i the arra index of the camera
\return the configuration information for a particular camera
*/
    MaxCamConfig* ccdConfig(int i) { return (MaxCamConfig*)ccdConfig()->At(i); }

/**
The maximum number of scope triggers to save
*/
    static const int MAX_N_TRIGGERS;

/**
\return an array of all scope data. If the scope data is stored as a TH1C, the TH2F array
will be generated on the fly and cached. 
*/
    TClonesArray* scopeData();

/**
\param i the array index of the trace to retrieve.  All of the traces for a single channel are grouped together.
\return a particular scope trace. If the scope data is stored as a TH1C, a TH1F aray will be generated
 on the fly and cached. 
*/
    TH1F*         scopeData(int i);

/**
\param iTrigger the number of the trigger
\param board the number of the board
\param channel the number of the channel on the board
\return the scope trace for a specified channel for a specified trigger. If the scope 
traces are saved as TH1C's, a TH1F will be generated on the fly and cached. 
*/
    TH1F*         scopeData(int iTrigger, int board, int channel);    

  /**
     returns the scope waveform for trigger itrig on channel ichan
     \param[in] ichan  --  channel number (0,1,2,3,4,...)
     \param[in] itrig  --  trigger number in this event (0,1,2,...)
   */
  TH1F* scopeData(int ichan, int itrig);



/**The maximum number of scope configurations to save */
    static const int MAX_N_SCOPE_CONFIGS;

/**
\return an array holding configuration information for each scope
*/
    TClonesArray*   scopeDataInfo() { return _scopeDataInfo; }

/**
\param i the array number of the scope
\return the configuration information for a particular scope
*/
    ScopeDataInfo*  scopeDataInfo(int i) { return (ScopeDataInfo*)scopeDataInfo()->At(i); }
    
/** Returns the event number
 * @returns the stored event number */
    int eventNumber() { return _eventNumber; }

/** Sets the event number
 * @param iev the event number
 * */
    void setEventNumber(int iev) { _eventNumber=iev; }

/** Increments the stored event number */ 
    void increaseEventNumber() { _eventNumber++; }

/** 
 * @return the run number */
    int runNumber() { return _runNumber; }

/** Set the run number 
 *  @param irun the run number to set to 
 */
    void setRunNumber(int irun) { _runNumber=irun; }

    // MC Truth
    
/**The maximum number of McDark (G4 MC) tracks to save*/
    static const int MAX_N_MCDARK_TRACKS;

/**
\return an array of all McDark MC tracks
*/
    TClonesArray*   mcTrack() { return _mcDarkTrackList; }

/**
\param i the number of the track
\return a particular McDark MC track
*/
    McDarkTrack*    mcTrack(int i) { return (McDarkTrack*)_mcDarkTrackList->At(i); }

/**
Print info about all tracks
*/
    void printMcTracks();

/**
The maximum number of McDarkDigi (G4 MC) objects to save
*/
    static const int MAX_N_MCDARK_CCD_DIGIS;

/**
\return an array of all McDarkDigi info
*/
    TClonesArray*   mcCcdDigi() { return _mcDarkCcdDigiList; }

/**
\return the info from a particulr McDarkDigi channel
*/
    McDarkDigi*     mcCcdDigi(int i) { return (McDarkDigi*)_mcDarkCcdDigiList->At(i); }
    
    
    /** tag to set if event memory already cleared before destructor is called*/
    bool isCleared; //! 


    /** Return raw ccd data. This may either be a TH2F or a TH2S, depending
     * on the vintage of the data.
     *
     * For data stored as TH2F's, there is no difference between calling this and ccdData. 
     *
     * @param i the index of the image to return 
     * @return an image. 
     * */
    TH2 * rawCcdData(int i) { return(TH2*)  _ccdData->At(i);}

    /** Return array of raw ccd data. This may either be a TH2F or a TH2S, depending
     * on the vintage of the data.
     *
     * For data stored as TH2F's, there is no difference between calling this and ccdData. 
     *
     * @return array of images
     * */
    TClonesArray * rawCcdData() { return _ccdData;}

    /** Return raw overscan data. This may be either a TH2F or a TH2S, depending
     *  on the vintage of the data. For data stored as TH2F's, there is no difference
     *  between calling this and overscan()
     *
     *  @param i the index of the overscan to return
     *  @return the overscan
     */
    TH2 * rawOverscan(int i) { return(TH2*)  _overscan->At(i);}

    /** Return array of raw overscan data. This may be either a TH2F or a TH2S, depending
     *  on the vintage of the data. For data stored as TH2F's, there is no difference
     *  between calling this and overscan()
     *
     *  @return array of ovesrcan images
     */
    TClonesArray * rawOverscan(){ return _overscan;}

    /** Return raw scope data. This may be either a TH1F or a TH1C, depending
     *  on the vintage of the data. For data stored as TH1F's, there is no difference
     *  between calling this and scopeData()
     *
     *  @param i the index of the scope Data to return
     *  @return the associated scope trace
     */
    ScopeWaveformData * rawScopeData(int i) { return(ScopeWaveformData*)  _scopeData->At(i);}

    /** Return an array of raw scope data. This may be either a TH1F or a TH1C, depending
     *  on the vintage of the data. For data stored as TH1F's, there is no difference
     *  between calling this and scopeData()
     *
     *  @return array of scope traces
     */

    TClonesArray * rawScopeData() { return _scopeData;}

    /** Clear the TH2F / TH1F cache */
    void clearCache(); 
private:    
    
    void make_all_cache(const char * which); 
    void make_cache(unsigned int index, const char * which); 
    bool check_cache(unsigned int index, const char * which); 

    TClonesArray *_ccdData; ///< ccd images
    TClonesArray *_ccdDataClonesCache; //!
    vector<TH2F*> _ccdDataCache; //!
    TClonesArray *_overscan; ///< overscan data
    TClonesArray *_overscanClonesCache; //!
    vector<TH2F*> _overscanCache; //!
    TClonesArray *_ccdConfig; ///< ccd configuration
    TClonesArray *_scopeData; ///< waveforms
    TClonesArray *_scopeDataClonesCache; //!
    vector<TH1F*> _scopeDataCache; //!
    TClonesArray *_scopeDataInfo; ///< trigger information
    bool _cache_dirty; //!
    
    TClonesArray *_experConfig; ///< stores pressures, voltages, currents, temperatures
    
    TDatime *_dtime; ///< time-stamp
    TTimeStamp *_tstime; ///< UTC time-stamp
   
    int _runNumber;///<the run nnumber
    int _eventNumber;///<the event number

    TClonesArray *_mcDarkTrackList; ///< list of MC tracks
    TClonesArray *_mcDarkCcdDigiList; ///< list of MC pixels in CCD   

    ClassDef(DmtpcEvent,5)
        
};



#endif
